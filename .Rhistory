left_join(
play_features %>%
select(game_id, play_id, nfl_id, frame_id, vx, vy, ax, ay, s, a, o, dir,
speed_sq, acc_sq, vx_vy_angle, dir_change,
orientation_cos, orientation_sin, dir_cos, dir_sin,
x_lag1, y_lag1, vx_lag1, vy_lag1, ax_lag1, ay_lag1, n_past,
play_direction, player_position, player_role),
by = c("game_id","play_id","nfl_id","frame_id")
)
# Build dummy matrix for test set
dummies_test <- model.matrix(~ . - 1, data = play_test[categorical_vars]) %>% as.data.frame()
test_predictors <- play_test %>%
select(vx, vy, ax, ay, s, a, o, dir,
speed_sq, acc_sq, vx_vy_angle, dir_change,
orientation_cos, orientation_sin, dir_cos, dir_sin,
x_lag1, y_lag1, vx_lag1, vy_lag1, ax_lag1, ay_lag1, n_past) %>%
bind_cols(dummies_test)
# ====================================================
# 5. Predict x and y for output frames
# ====================================================
preds <- predict(mv_lm, newdata = test_predictors)
play_output_preds <- play_test %>%
bind_cols(as.data.frame(preds)) %>%
rename(x_pred = x_next, y_pred = y_next)
View(preds)
preds %>% drop_na()
# ====================================================
# 6. Optional: Evaluate RMSE if x,y exist in output
# ====================================================
if(all(c("x","y") %in% colnames(play_output_preds))){
rmse_x <- sqrt(mean((play_output_preds$x - play_output_preds$x_pred)^2))
rmse_y <- sqrt(mean((play_output_preds$y - play_output_preds$y_pred)^2))
overall_rmse <- sqrt(mean((play_output_preds$x - play_output_preds$x_pred)^2 +
(play_output_preds$y - play_output_preds$y_pred)^2))
cat("=== Multivariate LM ===\n")
cat("RMSE x:", rmse_x, "\n")
cat("RMSE y:", rmse_y, "\n")
cat("Overall RMSE:", overall_rmse, "\n")
}
View(preds)
preds %>% drop_na()
View(preds)
View(preds)
plot(x=(preds$x_next - play_output$x), y=(preds$y_next - play_output$y)))
plot(x=(preds$x_next - play_output$x), y=(preds$y_next - play_output$y))
change_x = preds$x_next - play_output$x
preds$diff_x = preds$x_next - play_output$x
View(preds)
View(play_output_preds)
# Create a sample data frame
df <- data.frame(
colA = c(10, 15, 20, 25),
colB = c(5, 7, 9, 11)
)
# Subtract colB from colA and store the result in a new column named 'difference'
df$difference <- df$colA - df$colB
# 1. Extract columns from df_1 and add them to df_2
preds$x <- play_output$x
View(preds)
# ====================================================
# 5. Predict x and y for output frames
# ====================================================
preds <- predict(mv_lm, newdata = test_predictors)
# 1. Extract columns from df_1 and add them to df_2
preds$x <- play_output$x
# ====================================================
# 5. Predict x and y for output frames
# ====================================================
preds <- predict(mv_lm, newdata = test_predictors)
play_output_preds <- play_test %>%
bind_cols(as.data.frame(preds)) %>%
rename(x_pred = x_next, y_pred = y_next)
View(play_output_preds)
diff_x <- play_output_preds$x - play_output_preds$x_next
diff_x <- play_output_preds$x - play_output_preds$x_pred
diff_y <- play_output_preds$y - play_output_preds$y_pred
plot(x=diff_x, y=diff_y)
unique(play_output_preds$play_id)
unique_play_data <- data_df %>%
group_by(play_id) %>%
summarise(
avg_diff_x = mean(diff_x, na.rm = TRUE),
avg_diff_y = mean(diff_y, na.rm = TRUE)
# You might also calculate the total distance or other metrics here
)
unique_play_data <- play_output_preds %>%
group_by(play_id) %>%
summarise(
avg_diff_x = mean(diff_x, na.rm = TRUE),
avg_diff_y = mean(diff_y, na.rm = TRUE)
# You might also calculate the total distance or other metrics here
)
# 2. Plot the aggregated data using the new summary data frame
plot(x = unique_play_data$avg_diff_x, y = unique_play_data$avg_diff_y,
main = "Differences in X and Y (One point per Play ID)",
xlab = "Average Difference in X",
ylab = "Average Difference in Y",
pch = 19, # Use solid points
col = "blue")
# 1. Get all unique play IDs
unique_plays <- unique(data_df$play_id)
# 2. Loop through each unique play ID
for (current_play_id in unique_plays) {
# Filter the data frame to get only points for the current play ID
play_data <- subset(data_df, play_id == current_play_id)
# Create a plot for this specific play
plot(x = play_data$x, y = play_data$y,
main = paste("Play ID:", current_play_id), # Set the plot title
xlab = "X Coordinate",
ylab = "Y Coordinate",
type = "b",   # 'b' plots both points and lines
pch = 19,     # Solid points
col = "blue",
# Set consistent axis limits if you want comparable plots:
xlim = c(min(data_df$x, na.rm = TRUE), max(data_df$x, na.rm = TRUE)),
ylim = c(min(data_df$y, na.rm = TRUE), max(data_df$y, na.rm = TRUE))
)
# Optional: If you want R to pause between plots for viewing:
# locator(1)
}
# 1. Get all unique play IDs
unique_plays <- unique(play_output_preds$play_id)
# 2. Loop through each unique play ID
for (current_play_id in unique_plays) {
# Filter the data frame to get only points for the current play ID
play_data <- subset(data_df, play_id == current_play_id)
# Create a plot for this specific play
plot(x = play_data$x, y = play_data$y,
main = paste("Play ID:", current_play_id), # Set the plot title
xlab = "X Coordinate",
ylab = "Y Coordinate",
type = "b",   # 'b' plots both points and lines
pch = 19,     # Solid points
col = "blue",
# Set consistent axis limits if you want comparable plots:
xlim = c(min(data_df$x, na.rm = TRUE), max(data_df$x, na.rm = TRUE)),
ylim = c(min(data_df$y, na.rm = TRUE), max(data_df$y, na.rm = TRUE))
)
# Optional: If you want R to pause between plots for viewing:
# locator(1)
}
# 1. Get all unique play IDs
unique_plays <- unique(play_output_preds$play_id)
# 2. Loop through each unique play ID
for (current_play_id in unique_plays) {
# Filter the data frame to get only points for the current play ID
play_data <- subset(play_output_preds, play_id == current_play_id)
# Create a plot for this specific play
plot(x = play_data$x, y = play_data$y,
main = paste("Play ID:", current_play_id), # Set the plot title
xlab = "X Coordinate",
ylab = "Y Coordinate",
type = "b",   # 'b' plots both points and lines
pch = 19,     # Solid points
col = "blue",
# Set consistent axis limits if you want comparable plots:
xlim = c(min(play_output_preds$x, na.rm = TRUE), max(play_output_preds$x, na.rm = TRUE)),
ylim = c(min(play_output_preds$y, na.rm = TRUE), max(play_output_preds$y, na.rm = TRUE))
)
# Optional: If you want R to pause between plots for viewing:
# locator(1)
}
play_id == 1180
# Uncomment whichever you want
play_input <- in_w11 %>%
#   filter(game_id == game_id_to_use)
filter(play_id == 1180)
play_output <- out_w11 %>%
# filter(game_id == game_id_to_use)
filter(play_id == 1180)
# ====================================================
# 1. Feature engineering on input
# ====================================================
play_features <- play_input %>%
arrange(nfl_id, frame_id) %>%
# compute velocities and accelerations
mutate(
dir_rad = dir * pi / 180,
vx = s * cos(dir_rad),
vy = s * sin(dir_rad),
ax = a * cos(dir_rad),
ay = a * sin(dir_rad),
# directionality & angular changes
speed_sq = s^2,
acc_sq = a^2,
vx_vy_angle = atan2(vy, vx),
dir_change = dir - lag(dir),
orientation_cos = cos(o * pi/180),
orientation_sin = sin(o * pi/180),
dir_cos = cos(dir * pi/180),
dir_sin = sin(dir * pi/180)
) %>%
group_by(nfl_id) %>%
mutate(
x_lag1 = lag(x, 1),
y_lag1 = lag(y, 1),
vx_lag1 = lag(vx, 1),
vy_lag1 = lag(vy, 1),
ax_lag1 = lag(ax, 1),
ay_lag1 = lag(ay, 1),
n_past = row_number() - 1
) %>%
ungroup() %>%
filter(player_to_predict == TRUE)
play_features <- play_features %>%
group_by(nfl_id, game_id, play_id) %>%
arrange(frame_id) %>%
mutate(
x_next = lead(x, 1),
y_next = lead(y, 1)
) %>%
ungroup()
# ====================================================
# 2. Prepare model matrix
# ====================================================
# Convert categorical variables to dummies
categorical_vars <- c("play_direction", "player_position", "player_role")
dummies <- model.matrix(~ . - 1, data = play_features[categorical_vars]) %>% as.data.frame()
# Combine numeric + dummy predictors
predictors <- play_features %>%
select(vx, vy, ax, ay, s, a, o, dir,
speed_sq, acc_sq, vx_vy_angle, dir_change,
orientation_cos, orientation_sin, dir_cos, dir_sin,
x_lag1, y_lag1, vx_lag1, vy_lag1, ax_lag1, ay_lag1, n_past) %>%
bind_cols(dummies)
fit_data <- bind_cols(
predictors,
play_features[, c("x_next", "y_next")]
) %>%
drop_na()  # remove rows where x_next or y_next are NA
# ====================================================
# 3. Fit multivariate linear model
# ====================================================
# mv_lm <- lm(cbind(x_next, y_next) ~ ., data = bind_cols(predictors, play_features[, c("x_next", "y_next")]))
mv_lm <- lm(cbind(x_next, y_next) ~ ., data = fit_data)
# ====================================================
# 4. Generate features for output frames
# ====================================================
# Join the same features to play_output
play_test <- play_output %>%
left_join(
play_features %>%
select(game_id, play_id, nfl_id, frame_id, vx, vy, ax, ay, s, a, o, dir,
speed_sq, acc_sq, vx_vy_angle, dir_change,
orientation_cos, orientation_sin, dir_cos, dir_sin,
x_lag1, y_lag1, vx_lag1, vy_lag1, ax_lag1, ay_lag1, n_past,
play_direction, player_position, player_role),
by = c("game_id","play_id","nfl_id","frame_id")
)
# Build dummy matrix for test set
dummies_test <- model.matrix(~ . - 1, data = play_test[categorical_vars]) %>% as.data.frame()
test_predictors <- play_test %>%
select(vx, vy, ax, ay, s, a, o, dir,
speed_sq, acc_sq, vx_vy_angle, dir_change,
orientation_cos, orientation_sin, dir_cos, dir_sin,
x_lag1, y_lag1, vx_lag1, vy_lag1, ax_lag1, ay_lag1, n_past) %>%
bind_cols(dummies_test)
# ====================================================
# 5. Predict x and y for output frames
# ====================================================
preds <- predict(mv_lm, newdata = test_predictors)
play_output_preds <- play_test %>%
bind_cols(as.data.frame(preds)) %>%
rename(x_pred = x_next, y_pred = y_next)
# ====================================================
# 6. Optional: Evaluate RMSE if x,y exist in output
# ====================================================
if(all(c("x","y") %in% colnames(play_output_preds))){
rmse_x <- sqrt(mean((play_output_preds$x - play_output_preds$x_pred)^2))
rmse_y <- sqrt(mean((play_output_preds$y - play_output_preds$y_pred)^2))
overall_rmse <- sqrt(mean((play_output_preds$x - play_output_preds$x_pred)^2 +
(play_output_preds$y - play_output_preds$y_pred)^2))
cat("=== Multivariate LM ===\n")
cat("RMSE x:", rmse_x, "\n")
cat("RMSE y:", rmse_y, "\n")
cat("Overall RMSE:", overall_rmse, "\n")
}
diff_x <- play_output_preds$x - play_output_preds$x_pred
diff_y <- play_output_preds$y - play_output_preds$y_pred
# 1. Get all unique play IDs
unique_plays <- unique(play_output_preds$play_id)
# 2. Loop through each unique play ID
for (current_play_id in unique_plays) {
# Filter the data frame to get only points for the current play ID
play_data <- subset(play_output_preds, play_id == current_play_id)
# Create a plot for this specific play
plot(x = play_data$x, y = play_data$y,
main = paste("Play ID:", current_play_id), # Set the plot title
xlab = "X Coordinate",
ylab = "Y Coordinate",
type = "b",   # 'b' plots both points and lines
pch = 19,     # Solid points
col = "blue",
# Set consistent axis limits if you want comparable plots:
xlim = c(min(play_output_preds$x, na.rm = TRUE), max(play_output_preds$x, na.rm = TRUE)),
ylim = c(min(play_output_preds$y, na.rm = TRUE), max(play_output_preds$y, na.rm = TRUE))
)
# Optional: If you want R to pause between plots for viewing:
# locator(1)
}
# ====================================================
# 0. Select play or game
# ====================================================
# game_id_to_use <- 2023111906
game_id_to_use <- 1180
play_id == 1180
# Uncomment whichever you want
play_input <- in_w11 %>%
#   filter(game_id == game_id_to_use)
filter(play_id == 1180)
play_output <- out_w11 %>%
# filter(game_id == game_id_to_use)
filter(play_id == 1180)
# ====================================================
# 1. Feature engineering on input
# ====================================================
play_features <- play_input %>%
arrange(nfl_id, frame_id) %>%
# compute velocities and accelerations
mutate(
dir_rad = dir * pi / 180,
vx = s * cos(dir_rad),
vy = s * sin(dir_rad),
ax = a * cos(dir_rad),
ay = a * sin(dir_rad),
# directionality & angular changes
speed_sq = s^2,
acc_sq = a^2,
vx_vy_angle = atan2(vy, vx),
dir_change = dir - lag(dir),
orientation_cos = cos(o * pi/180),
orientation_sin = sin(o * pi/180),
dir_cos = cos(dir * pi/180),
dir_sin = sin(dir * pi/180)
) %>%
group_by(nfl_id) %>%
mutate(
x_lag1 = lag(x, 1),
y_lag1 = lag(y, 1),
vx_lag1 = lag(vx, 1),
vy_lag1 = lag(vy, 1),
ax_lag1 = lag(ax, 1),
ay_lag1 = lag(ay, 1),
n_past = row_number() - 1
) %>%
ungroup() %>%
filter(player_to_predict == TRUE)
play_features <- play_features %>%
group_by(nfl_id, game_id, play_id) %>%
arrange(frame_id) %>%
mutate(
x_next = lead(x, 1),
y_next = lead(y, 1)
) %>%
ungroup()
# ====================================================
# 2. Prepare model matrix
# ====================================================
# Convert categorical variables to dummies
categorical_vars <- c("play_direction", "player_position", "player_role")
dummies <- model.matrix(~ . - 1, data = play_features[categorical_vars]) %>% as.data.frame()
# Combine numeric + dummy predictors
predictors <- play_features %>%
select(vx, vy, ax, ay, s, a, o, dir,
speed_sq, acc_sq, vx_vy_angle, dir_change,
orientation_cos, orientation_sin, dir_cos, dir_sin,
x_lag1, y_lag1, vx_lag1, vy_lag1, ax_lag1, ay_lag1, n_past) %>%
bind_cols(dummies)
fit_data <- bind_cols(
predictors,
play_features[, c("x_next", "y_next")]
) %>%
drop_na()  # remove rows where x_next or y_next are NA
# ====================================================
# 3. Fit multivariate linear model
# ====================================================
# mv_lm <- lm(cbind(x_next, y_next) ~ ., data = bind_cols(predictors, play_features[, c("x_next", "y_next")]))
mv_lm <- lm(cbind(x_next, y_next) ~ ., data = fit_data)
# ====================================================
# 4. Generate features for output frames
# ====================================================
# Join the same features to play_output
play_test <- play_output %>%
left_join(
play_features %>%
select(game_id, play_id, nfl_id, frame_id, vx, vy, ax, ay, s, a, o, dir,
speed_sq, acc_sq, vx_vy_angle, dir_change,
orientation_cos, orientation_sin, dir_cos, dir_sin,
x_lag1, y_lag1, vx_lag1, vy_lag1, ax_lag1, ay_lag1, n_past,
play_direction, player_position, player_role),
by = c("game_id","play_id","nfl_id","frame_id")
)
# Build dummy matrix for test set
dummies_test <- model.matrix(~ . - 1, data = play_test[categorical_vars]) %>% as.data.frame()
test_predictors <- play_test %>%
select(vx, vy, ax, ay, s, a, o, dir,
speed_sq, acc_sq, vx_vy_angle, dir_change,
orientation_cos, orientation_sin, dir_cos, dir_sin,
x_lag1, y_lag1, vx_lag1, vy_lag1, ax_lag1, ay_lag1, n_past) %>%
bind_cols(dummies_test)
# ====================================================
# 5. Predict x and y for output frames
# ====================================================
preds <- predict(mv_lm, newdata = test_predictors)
play_output_preds <- play_test %>%
bind_cols(as.data.frame(preds)) %>%
rename(x_pred = x_next, y_pred = y_next)
# ====================================================
# 6. Optional: Evaluate RMSE if x,y exist in output
# ====================================================
if(all(c("x","y") %in% colnames(play_output_preds))){
rmse_x <- sqrt(mean((play_output_preds$x - play_output_preds$x_pred)^2))
rmse_y <- sqrt(mean((play_output_preds$y - play_output_preds$y_pred)^2))
overall_rmse <- sqrt(mean((play_output_preds$x - play_output_preds$x_pred)^2 +
(play_output_preds$y - play_output_preds$y_pred)^2))
cat("=== Multivariate LM ===\n")
cat("RMSE x:", rmse_x, "\n")
cat("RMSE y:", rmse_y, "\n")
cat("Overall RMSE:", overall_rmse, "\n")
}
diff_x <- play_output_preds$x - play_output_preds$x_pred
diff_y <- play_output_preds$y - play_output_preds$y_pred
# 1. Get all unique play IDs
unique_plays <- unique(play_output_preds$play_id)
# 2. Loop through each unique play ID
for (current_play_id in unique_plays) {
# Filter the data frame to get only points for the current play ID
play_data <- subset(play_output_preds, play_id == current_play_id)
# Create a plot for this specific play
plot(x = play_data$x, y = play_data$y,
main = paste("Play ID:", current_play_id), # Set the plot title
xlab = "X Coordinate",
ylab = "Y Coordinate",
type = "b",   # 'b' plots both points and lines
pch = 19,     # Solid points
col = "blue",
# Set consistent axis limits if you want comparable plots:
xlim = c(min(play_output_preds$x, na.rm = TRUE), max(play_output_preds$x, na.rm = TRUE)),
ylim = c(min(play_output_preds$y, na.rm = TRUE), max(play_output_preds$y, na.rm = TRUE))
)
# Optional: If you want R to pause between plots for viewing:
# locator(1)
}
# ====================================================
# 0. Select play or game
# ====================================================
# game_id_to_use <- 2023111906
game_id_to_use <- 1180
play_id == 1180
# ====================================================
# 0. Select play or game
# ====================================================
# game_id_to_use <- 2023111906
game_id_to_use <- 1180
play_id <- 1180
# Uncomment whichever you want
play_input <- in_w11 %>%
#   filter(game_id == game_id_to_use)
filter(play_id == 1180)
play_output <- out_w11 %>%
# filter(game_id == game_id_to_use)
filter(play_id == 1180)
# ====================================================
# 1. Feature engineering on input
# ====================================================
play_features <- play_input %>%
arrange(nfl_id, frame_id) %>%
# compute velocities and accelerations
mutate(
dir_rad = dir * pi / 180,
vx = s * cos(dir_rad),
vy = s * sin(dir_rad),
ax = a * cos(dir_rad),
ay = a * sin(dir_rad),
# directionality & angular changes
speed_sq = s^2,
acc_sq = a^2,
vx_vy_angle = atan2(vy, vx),
dir_change = dir - lag(dir),
orientation_cos = cos(o * pi/180),
orientation_sin = sin(o * pi/180),
dir_cos = cos(dir * pi/180),
dir_sin = sin(dir * pi/180)
) %>%
group_by(nfl_id) %>%
mutate(
x_lag1 = lag(x, 1),
y_lag1 = lag(y, 1),
vx_lag1 = lag(vx, 1),
vy_lag1 = lag(vy, 1),
ax_lag1 = lag(ax, 1),
ay_lag1 = lag(ay, 1),
n_past = row_number() - 1
) %>%
ungroup() %>%
filter(player_to_predict == TRUE)
play_features <- play_features %>%
group_by(nfl_id, game_id, play_id) %>%
arrange(frame_id) %>%
mutate(
x_next = lead(x, 1),
y_next = lead(y, 1)
) %>%
ungroup()
# ====================================================
# 2. Prepare model matrix
# ====================================================
# Convert categorical variables to dummies
categorical_vars <- c("play_direction", "player_position", "player_role")
dummies <- model.matrix(~ . - 1, data = play_features[categorical_vars]) %>% as.data.frame()
View(play_input)
unique(play_input$player_name)
